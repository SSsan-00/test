#!/usr/bin/env php
<?php
/**
 * fix_array_keys.php
 * ----------------------------------------------------------------
 *  ğŸ“Œ ç›®çš„
 *    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *    ãƒ¬ã‚¬ã‚·ãƒ¼ PHP/INC ãƒ•ã‚¡ã‚¤ãƒ«ã§ã€Œé…åˆ—ã‚­ãƒ¼ãŒã‚¯ã‚©ãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„ã€å•é¡Œã‚’
 *    è‡ªå‹•çš„ã«è£œæ­£ã™ã‚‹ãƒ¯ãƒ³ãƒ•ã‚¡ã‚¤ãƒ« CLI ãƒ„ãƒ¼ãƒ«ã€‚
 *
 *      1) å˜ä¸€è­˜åˆ¥å­ã‚­ãƒ¼   : å®šç¾©æ¸ˆã¿å®šæ•°ãªã‚‰å®Ÿå€¤ã¸ã€æœªå®šç¾©ãªã‚‰ 'è­˜åˆ¥å­' ã¸
 *      2) é€£çµæ¼”ç®—å­ã‚­ãƒ¼    : $var . bar   â†’ $var . 'bar'
 *                             CONST . bar  â†’ CONST . 'bar'ï¼ˆCONST æœªå®šç¾©æ™‚ï¼‰
 *                             CONST_OK . _EN â†’ CONST_OK . '_EN'ï¼ˆå·¦ã¯ä¿æŒï¼‰
 *      3) å¤šæ¬¡å…ƒé…åˆ—        : AST ãƒ™ãƒ¼ã‚¹ã§å†å¸°å‡¦ç†ã€æ·±ã•ç„¡åˆ¶é™
 *
 *    å¤‰æ›å¾Œãƒ•ã‚¡ã‚¤ãƒ«ã¯å…¥åŠ›ãƒ•ã‚©ãƒ«ãƒ€ã¨åŒã˜æ§‹é€ ã§ <input_dir>_fixed/ ã¸å‡ºåŠ›
 *    ï¼ˆç¬¬ 2 å¼•æ•°ã§å‡ºåŠ›ãƒ•ã‚©ãƒ«ãƒ€ã‚’è‡ªç”±ã«æŒ‡å®šå¯èƒ½ï¼‰
 *
 *  ğŸ’¡ ä¾å­˜
 *    composer require nikic/php-parser:^5
 *
 *  ğŸ’¡ ä½¿ã„æ–¹
 *      php fix_array_keys.php <input_dir> [output_dir]
 *
 *  âœ” Tested on PHP 8.1
 * ----------------------------------------------------------------
 */

declare(strict_types=1);

require_once __DIR__ . '/vendor/autoload.php';

use PhpParser\{Node, NodeTraverser, NodeVisitorAbstract, ParserFactory};
use PhpParser\Node\Expr;
use PhpParser\Node\Scalar\String_;
use PhpParser\PrettyPrinter\Standard;

/* ====== è¨­å®š ====== */
const TARGET_EXT = ['php', 'inc'];        // å¯¾è±¡æ‹¡å¼µå­ï¼ˆå°æ–‡å­—æ¯”è¼ƒï¼‰

/* ====== å¼•æ•°ãƒã‚§ãƒƒã‚¯ ====== */
if ($argc < 2) {
    fwrite(STDERR, "Usage: php fix_array_keys.php <input_dir> [output_dir]\n");
    exit(1);
}

$inputDir = realpath($argv[1]) ?: null;
if (!$inputDir || !is_dir($inputDir)) {
    fwrite(STDERR, "ERROR: invalid input directory: {$argv[1]}\n");
    exit(1);
}

$outputDir = $argv[2] ?? $inputDir . '_fixed';
if (!is_dir($outputDir) && !mkdir($outputDir, 0777, true)) {
    fwrite(STDERR, "ERROR: cannot create output directory: {$outputDir}\n");
    exit(1);
}

/* ====== ãƒ‘ãƒ¼ã‚µ & ãƒ—ãƒªãƒ³ã‚¿ ====== */
$parser  = (new ParserFactory)->createForNewestSupportedVersion();
$printer = new Standard();

/* ----------------------------------------------------------------
 * 1st pass: ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå…¨ä½“ã‹ã‚‰ã€Œå®šæ•° â†’ å€¤ã€ãƒãƒƒãƒ—ã‚’æ§‹ç¯‰
 * ---------------------------------------------------------------- */
$constantCollector = new class extends NodeVisitorAbstract {
    /** @var array<string,string>  CONST_NAME => value */
    public array $map = [];

    public function enterNode(Node $node): void
    {
        /* -- const å®£è¨€ ------------------------------ */
        // e.g.) const STATUS_OK = 'ok';
        if ($node instanceof Node\Stmt\Const_) {
            foreach ($node->consts as $const) {
                if ($const->value instanceof String_) {
                    $this->map[$const->name->toString()] = $const->value->value;
                }
            }
        }

        /* -- define() å‘¼ã³å‡ºã— ----------------------- */
        // e.g.) define('STATUS_OK', 'ok');
        if ($node instanceof Expr\FuncCall
            && $node->name instanceof Node\Name
            && strtolower($node->name->toString()) === 'define'
            && count($node->args) >= 2
            && $node->args[0]->value instanceof String_
            && $node->args[1]->value instanceof String_
        ) {
            $cName  = $node->args[0]->value->value;
            $cValue = $node->args[1]->value->value;
            $this->map[$cName] = $cValue;
        }
    }
};

/* -- ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªèµ°æŸ»ã—ã¦å®šæ•°åé›† -- */
foreach (traverseFiles($inputDir) as $filePath) {
    try {
        $ast = $parser->parse(file_get_contents($filePath));
        $tr  = new NodeTraverser();
        $tr->addVisitor($constantCollector);
        $tr->traverse($ast);
    } catch (\Throwable $e) {
        // è§£æä¸èƒ½ã§ã‚‚ç„¡è¦–ï¼ˆãƒ‘ã‚¹ 2 ã§ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚³ãƒ”ãƒ¼ã™ã‚‹ï¼‰
        fwrite(STDERR, "WARN skip constants ({$filePath}): {$e->getMessage()}\n");
    }
}
$constantMap = $constantCollector->map;

/* ----------------------------------------------------------------
 * 2nd pass: é…åˆ—ã‚­ãƒ¼ã‚’æ­£è¦åŒ–ã—ã¦æ›¸ãå‡ºã—
 * ---------------------------------------------------------------- */
$makeNormalizer = static function (array $constMap): NodeVisitorAbstract {

    // ã‚¯ãƒ­ãƒ¼ã‚¸ãƒ£: æœªå®šç¾©è­˜åˆ¥å­ â†’ String_ ã¸
    $quoteIfBareIdent = function (Node $node) use ($constMap): Node {
        // ConstFetch = æœªã‚¯ã‚©ãƒ¼ãƒˆè­˜åˆ¥å­ or å®šæ•°å‘¼ã³å‡ºã—
        if ($node instanceof Expr\ConstFetch) {
            $ident = $node->name->toString();
            if (!array_key_exists($ident, $constMap)) {
                // å®šæ•°æœªå®šç¾© â†’ 'è­˜åˆ¥å­' ã¸ç½®æ›
                return new String_($ident, $node->getAttributes());
            }
        }
        return $node; // ãã®ã¾ã¾
    };

    return new class($constMap, $quoteIfBareIdent) extends NodeVisitorAbstract {

        public function __construct(
            private readonly array   $constMap,
            private readonly Closure $quote
        ) {}

        /**
         * enterNode() ã§å¿…è¦ã«å¿œã˜ã¦ãƒãƒ¼ãƒ‰ã‚’ç½®æ›
         */
        public function enterNode(Node $node)
        {
            /* === (A) å˜ä¸€è­˜åˆ¥å­ã‚­ãƒ¼ ===================== */
            if ($node instanceof Expr\ArrayItem && $node->key instanceof Node) {
                if ($node->key instanceof Expr\ConstFetch) {
                    $name = $node->key->name->toString();

                    if (array_key_exists($name, $this->constMap)) {
                        // å®šç¾©æ¸ˆã¿å®šæ•° â†’ å®Ÿå€¤ã¸
                        return new Expr\ArrayItem(
                            $node->value,
                            new String_($this->constMap[$name]),
                            $node->byRef,
                            $node->getAttributes()
                        );
                    }
                    // æœªå®šç¾©è­˜åˆ¥å­ â†’ 'è­˜åˆ¥å­'
                    return new Expr\ArrayItem(
                        $node->value,
                        new String_($name),
                        $node->byRef,
                        $node->getAttributes()
                    );
                }
            }

            /* === (B) é€£çµæ¼”ç®—å­ã‚­ãƒ¼ ==================== */
            if ($node instanceof Expr\BinaryOp\Concat) {
                // å·¦å³ã«è£œå®Œã‚’é©ç”¨
                $newLeft  = ($this->quote)($node->left);
                $newRight = ($this->quote)($node->right);

                // ã©ã¡ã‚‰ã‹ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰æ–°ãƒãƒ¼ãƒ‰ã‚’è¿”ã™
                if ($newLeft !== $node->left || $newRight !== $node->right) {
                    return new Expr\BinaryOp\Concat($newLeft, $newRight, $node->getAttributes());
                }
            }

            return null; // å¤‰æ›´ãªã—
        }
    };
};

/* -- ãƒ¡ã‚¤ãƒ³å¤‰æ›ãƒ«ãƒ¼ãƒ— -- */
foreach (traverseFiles($inputDir) as $srcPath) {

    /* å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã‚’æ±ºå®šï¼ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªæ§‹é€ ç¶­æŒï¼‰ */
    $rel      = substr($srcPath, strlen($inputDir) + 1);
    $destPath = $outputDir . DIRECTORY_SEPARATOR . $rel;
    $destDir  = dirname($destPath);

    if (!is_dir($destDir) && !mkdir($destDir, 0777, true)) {
        fwrite(STDERR, "ERROR: cannot create directory {$destDir}\n");
        continue;
    }

    $code = file_get_contents($srcPath);
    if ($code === false) {
        fwrite(STDERR, "WARN: cannot read {$srcPath}\n");
        continue;
    }

    try {
        /* --- AST ç”Ÿæˆ & å¤‰æ› --- */
        $ast = $parser->parse($code);

        $tr = new NodeTraverser();
        $tr->addVisitor($makeNormalizer($constantMap));
        $fixedAst = $tr->traverse($ast);

        /* --- ã‚³ãƒ¼ãƒ‰å†ç”Ÿæˆ & ä¿å­˜ --- */
        $fixedCode = $printer->prettyPrintFile($fixedAst);
        file_put_contents($destPath, $fixedCode);

    } catch (\Throwable $e) {
        // ãƒ‘ãƒ¼ã‚¹å¤±æ•—: å…ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼ã ã‘
        fwrite(STDERR, "WARN raw copy ({$srcPath}): {$e->getMessage()}\n");
        file_put_contents($destPath, $code);
    }
}

/* *****************************************************************
 * é–¢æ•°: traverseFiles()
 * -----------------------------------------------------------------
 *  æŒ‡å®šãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚’æ·±ã•å„ªå…ˆã§èµ°æŸ»ã—ã€å¯¾è±¡æ‹¡å¼µå­ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ yield
 * **************************************************************** */
function traverseFiles(string $baseDir): iterable
{
    $iter = new RecursiveIteratorIterator(
        new RecursiveDirectoryIterator(
            $baseDir,
            FilesystemIterator::SKIP_DOTS | FilesystemIterator::FOLLOW_SYMLINKS
        ),
        RecursiveIteratorIterator::LEAVES_ONLY
    );

    /** @var SplFileInfo $info */
    foreach ($iter as $info) {
        if (!$info->isFile()) {
            continue;
        }
        $ext = strtolower($info->getExtension());
        if (in_array($ext, TARGET_EXT, true)) {
            yield $info->getPathname();
        }
    }
}